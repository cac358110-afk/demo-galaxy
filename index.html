<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Golden Planet & White Rings - Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; }
        canvas { display: block; }
        #instruction {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-family: sans-serif;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="instruction">Ultimate Particle System (High Performance)</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        // Sương mù đen sâu thẳm
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 45;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Tận dụng tối đa độ nét màn hình
        document.body.appendChild(renderer.domElement);

        // --- CẤU HÌNH HỆ THỐNG HẠT ---
        const particlesGeometry = new THREE.BufferGeometry();
        // MÁY KHỎE: Đẩy lên 80.000 hạt
        const particlesCount = 80000; 

        const posArray = new Float32Array(particlesCount * 3);
        const originalPosArray = new Float32Array(particlesCount * 3);
        const colorsArray = new Float32Array(particlesCount * 3); // Mảng chứa màu sắc
        const randomArray = new Float32Array(particlesCount); 

        const colorPlanet = new THREE.Color(0xffaa00); // Màu Cam cho hành tinh
        const colorRing = new THREE.Color(0xffffff);   // Màu Trắng cho vành đai

        for(let i = 0; i < particlesCount; i++) {
            const i3 = i * 3;
            
            // Tỷ lệ: 60% hạt làm Hành tinh, 40% hạt làm Vành đai
            const isRing = Math.random() > 0.6; 

            let x, y, z;
            let r, theta, phi;

            if (!isRing) {
                // --- TẠO HÀNH TINH (MÀU CAM) ---
                r = 16 * Math.cbrt(Math.random()); // Bán kính khối cầu
                theta = Math.random() * 2 * Math.PI;
                phi = Math.acos(2 * Math.random() - 1);

                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);

                // Gán màu CAM
                colorsArray[i3] = colorPlanet.r;
                colorsArray[i3+1] = colorPlanet.g;
                colorsArray[i3+2] = colorPlanet.b;

            } else {
                // --- TẠO VÀNH ĐAI (MÀU TRẮNG) ---
                // Vành đai rộng từ bán kính 22 đến 35
                const ringR = 22 + Math.random() * 13; 
                const ringTheta = Math.random() * 2 * Math.PI;
                
                x = ringR * Math.cos(ringTheta);
                z = ringR * Math.sin(ringTheta);
                // Độ dày vành đai mỏng
                y = (Math.random() - 0.5) * 0.8; 

                // Nghiêng vành đai một chút cho đẹp
                const tilt = 0.4; // Góc nghiêng
                const yNew = y * Math.cos(tilt) - z * Math.sin(tilt);
                const zNew = y * Math.sin(tilt) + z * Math.cos(tilt);
                y = yNew;
                z = zNew;

                // Gán màu TRẮNG
                colorsArray[i3] = colorRing.r;
                colorsArray[i3+1] = colorRing.g;
                colorsArray[i3+2] = colorRing.b;
            }

            posArray[i3] = x;
            posArray[i3+1] = y;
            posArray[i3+2] = z;

            originalPosArray[i3] = x;
            originalPosArray[i3+1] = y;
            originalPosArray[i3+2] = z;

            randomArray[i] = Math.random();
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3)); // Kích hoạt màu sắc từng hạt

        // Material đặc biệt để nhận màu (vertexColors: true)
        const material = new THREE.PointsMaterial({
            size: 0.15, // Hạt nhỏ mịn
            vertexColors: true, // Quan trọng: Cho phép mỗi hạt có màu riêng
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particlesMesh = new THREE.Points(particlesGeometry, material);
        scene.add(particlesMesh);

        // --- TƯƠNG TÁC ---
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
        });

        document.addEventListener('touchmove', (event) => {
            if(event.touches.length > 0) {
                mouseX = (event.touches[0].clientX - windowHalfX);
                mouseY = (event.touches[0].clientY - windowHalfY);
            }
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            // Xoay nhẹ
            particlesMesh.rotation.y = elapsedTime * 0.08;

            const positions = particlesGeometry.attributes.position.array;
            
            targetX = mouseX * 0.04; 
            targetY = -mouseY * 0.04;

            for(let i = 0; i < particlesCount; i++) {
                const i3 = i * 3;
                let px = positions[i3];
                let py = positions[i3+1];
                let pz = positions[i3+2];

                const dx = targetX - px;
                const dy = targetY - py;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Phạm vi tương tác
                const interactionRadius = 18;

                if (dist < interactionRadius) {
                    const force = (interactionRadius - dist) / interactionRadius;
                    const angle = Math.atan2(dy, dx);
                    const noise = randomArray[i]; 

                    // Lực đẩy mạnh mẽ
                    const push = 35 * force * (1 + noise);

                    positions[i3] -= Math.cos(angle) * 0.06 * push;
                    positions[i3+1] -= Math.sin(angle) * 0.06 * push;
                    positions[i3+2] += force * 8 * (Math.random() - 0.5); // Đẩy tung theo chiều sâu Z
                } else {
                    // Hồi phục chậm rãi
                    const originX = originalPosArray[i3];
                    const originY = originalPosArray[i3+1];
                    const originZ = originalPosArray[i3+2];

                    positions[i3] += (originX - positions[i3]) * 0.02;
                    positions[i3+1] += (originY - positions[i3+1]) * 0.02;
                    positions[i3+2] += (originZ - positions[i3+2]) * 0.02;
                }
            }
            
            particlesGeometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
