<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dual Rings Galaxy - Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; }
        canvas { display: block; }
        #instruction {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-family: sans-serif;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="instruction">Dual Rings Particle System (80k Particles)</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0015); // Sương mù nhẹ hơn chút để nhìn rõ vành ngoài

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 55; // Kéo xa camera ra một chút để thấy hết vành to

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- CẤU HÌNH SỐ LƯỢNG HẠT ---
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 80000; 

        const posArray = new Float32Array(particlesCount * 3);
        const originalPosArray = new Float32Array(particlesCount * 3);
        const colorsArray = new Float32Array(particlesCount * 3); 
        const randomArray = new Float32Array(particlesCount); 

        const colorPlanet = new THREE.Color(0xffaa00); // Cam (Hành tinh)
        const colorRing = new THREE.Color(0xffffff);   // Trắng (Vành đai)

        for(let i = 0; i < particlesCount; i++) {
            const i3 = i * 3;
            
            // Chia tỷ lệ hạt:
            // 0 - 0.45: Hành tinh (45%)
            // 0.45 - 0.70: Vành nhỏ (25%)
            // 0.70 - 1.0: Vành to (30%)
            const type = Math.random(); 

            let x, y, z;
            let r, theta, phi;

            if (type < 0.45) {
                // === 1. HÀNH TINH (PLANET) ===
                r = 15 * Math.cbrt(Math.random()); 
                theta = Math.random() * 2 * Math.PI;
                phi = Math.acos(2 * Math.random() - 1);

                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);

                // Màu CAM
                colorsArray[i3] = colorPlanet.r;
                colorsArray[i3+1] = colorPlanet.g;
                colorsArray[i3+2] = colorPlanet.b;

            } else {
                // === VÀNH ĐAI (RINGS) ===
                let ringR;
                
                if (type < 0.70) {
                    // === 2. VÀNH ĐAI TRONG (INNER RING) ===
                    // Bán kính từ 19 đến 27
                    ringR = 19 + Math.random() * 8;
                } else {
                    // === 3. VÀNH ĐAI NGOÀI (OUTER RING) ===
                    // Bán kính từ 32 đến 48 (Tạo khoảng hở từ 27->32)
                    ringR = 32 + Math.random() * 16;
                }

                const ringTheta = Math.random() * 2 * Math.PI;
                x = ringR * Math.cos(ringTheta);
                z = ringR * Math.sin(ringTheta);
                y = (Math.random() - 0.5) * 0.6; // Độ dày mỏng

                // Nghiêng vành đai (Tilt)
                const tilt = 0.4; 
                const yNew = y * Math.cos(tilt) - z * Math.sin(tilt);
                const zNew = y * Math.sin(tilt) + z * Math.cos(tilt);
                y = yNew;
                z = zNew;

                // Màu TRẮNG
                colorsArray[i3] = colorRing.r;
                colorsArray[i3+1] = colorRing.g;
                colorsArray[i3+2] = colorRing.b;
            }

            posArray[i3] = x;
            posArray[i3+1] = y;
            posArray[i3+2] = z;

            originalPosArray[i3] = x;
            originalPosArray[i3+1] = y;
            originalPosArray[i3+2] = z;

            randomArray[i] = Math.random();
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

        const material = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particlesMesh = new THREE.Points(particlesGeometry, material);
        scene.add(particlesMesh);

        // --- TƯƠNG TÁC ---
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
        });
        document.addEventListener('touchmove', (event) => {
            if(event.touches.length > 0) {
                mouseX = (event.touches[0].clientX - windowHalfX);
                mouseY = (event.touches[0].clientY - windowHalfY);
            }
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            particlesMesh.rotation.y = elapsedTime * 0.08;

            const positions = particlesGeometry.attributes.position.array;
            
            // Chỉnh độ nhạy chuột
            targetX = mouseX * 0.05; 
            targetY = -mouseY * 0.05;

            for(let i = 0; i < particlesCount; i++) {
                const i3 = i * 3;
                let px = positions[i3];
                let py = positions[i3+1];
                let pz = positions[i3+2];

                const dx = targetX - px;
                const dy = targetY - py;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Tăng bán kính tương tác lên để quét được cả vành ngoài
                const interactionRadius = 25; 

                if (dist < interactionRadius) {
                    const force = (interactionRadius - dist) / interactionRadius;
                    const angle = Math.atan2(dy, dx);
                    const noise = randomArray[i]; 

                    // Lực đẩy
                    const push = 40 * force * (1 + noise);

                    positions[i3] -= Math.cos(angle) * 0.08 * push;
                    positions[i3+1] -= Math.sin(angle) * 0.08 * push;
                    positions[i3+2] += force * 10 * (Math.random() - 0.5); 
                } else {
                    const originX = originalPosArray[i3];
                    const originY = originalPosArray[i3+1];
                    const originZ = originalPosArray[i3+2];

                    positions[i3] += (originX - positions[i3]) * 0.025;
                    positions[i3+1] += (originY - positions[i3+1]) * 0.025;
                    positions[i3+2] += (originZ - positions[i3+2]) * 0.025;
                }
            }
            
            particlesGeometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
