<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Magic Galaxy Interaction</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        #instruction {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="instruction">Di chuột vào tâm để phá vỡ hành tinh</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        // Sương mù dày hơn để tạo chiều sâu tối tăm
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40; // Kéo camera gần hơn một chút

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- CẤU HÌNH HẠT ---
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 30000; // TĂNG GẤP ĐÔI SỐ HẠT

        const posArray = new Float32Array(particlesCount * 3);
        const originalPosArray = new Float32Array(particlesCount * 3);
        
        // Mảng lưu tốc độ ngẫu nhiên cho từng hạt để nó bay không đều nhau
        const randomArray = new Float32Array(particlesCount); 

        for(let i = 0; i < particlesCount; i++) {
            const i3 = i * 3;
            
            // Tạo hình cầu đặc (Solid Sphere) thay vì rỗng để nhìn dày hơn
            const r = 18 * Math.pow(Math.random(), 1/3); 
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);

            let x = r * Math.sin(phi) * Math.cos(theta);
            let y = r * Math.sin(phi) * Math.sin(theta);
            let z = r * Math.cos(phi);

            // Biến hình cầu thành đĩa dẹt (Galaxy shape)
            y = y * 0.4; // Ép dẹt trục Y

            // Xoay nghiêng một chút cho đẹp
            const tilt = 0.5;
            const yNew = y * Math.cos(tilt) - z * Math.sin(tilt);
            const zNew = y * Math.sin(tilt) + z * Math.cos(tilt);
            y = yNew;
            z = zNew;

            posArray[i3] = x;
            posArray[i3+1] = y;
            posArray[i3+2] = z;

            originalPosArray[i3] = x;
            originalPosArray[i3+1] = y;
            originalPosArray[i3+2] = z;

            randomArray[i] = Math.random();
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

        // Material đẹp hơn
        const material = new THREE.PointsMaterial({
            size: 0.12, // Hạt nhỏ lại cho mịn
            color: 0xffaa33, // Vàng cam cháy
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending, // Chế độ hòa trộn ánh sáng
            depthWrite: false
        });

        const particlesMesh = new THREE.Points(particlesGeometry, material);
        scene.add(particlesMesh);

        // --- TƯƠNG TÁC CHUỘT ---
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;

        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        // Xử lý chuột mượt hơn
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
        });
        
        // Xử lý cảm ứng
        document.addEventListener('touchmove', (event) => {
             if(event.touches.length > 0) {
                mouseX = (event.touches[0].clientX - windowHalfX);
                mouseY = (event.touches[0].clientY - windowHalfY);
            }
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            // Xoay chậm toàn bộ hệ thống
            particlesMesh.rotation.y = elapsedTime * 0.05;

            // Update vị trí hạt
            const positions = particlesGeometry.attributes.position.array;

            // Biến đổi tọa độ chuột cho khớp với không gian 3D
            targetX = mouseX * 0.03; 
            targetY = -mouseY * 0.03;

            for(let i = 0; i < particlesCount; i++) {
                const i3 = i * 3;
                
                // Vị trí hiện tại
                let px = positions[i3];
                let py = positions[i3+1];
                let pz = positions[i3+2];

                // Vị trí gốc (đã tính toán xoay theo Mesh để so sánh chính xác hơn)
                // Tuy nhiên để tối ưu hiệu năng ta sẽ so sánh tương đối với tâm chuột
                
                // Tính khoảng cách tới chuột
                // Do mesh xoay, ta cần ước lượng vị trí chuột trên mặt phẳng chiếu
                const dx = targetX - px;
                const dy = targetY - py;
                
                // Khoảng cách trong mặt phẳng 2D (chỉ X và Y)
                const dist = Math.sqrt(dx*dx + dy*dy);

                // --- LOGIC VẬT LÝ MỚI ---
                
                // BÁN KÍNH TÁC ĐỘNG LỚN HƠN (Tăng từ 8 lên 20)
                const interactionRadius = 15; 
                
                if (dist < interactionRadius) {
                    // Lực đẩy cực mạnh dựa trên khoảng cách (càng gần càng mạnh)
                    const force = (interactionRadius - dist) / interactionRadius;
                    
                    // Tạo góc đẩy
                    const angle = Math.atan2(dy, dx);
                    
                    // Thêm độ nhiễu (noise) để hạt bay loạn xạ như video
                    const noise = randomArray[i] * 2; 

                    // Đẩy hạt ra xa cực mạnh
                    const pushFactor = 30 * force * noise; // Hệ số đẩy lớn

                    positions[i3] -= Math.cos(angle) * 0.05 * pushFactor;
                    positions[i3+1] -= Math.sin(angle) * 0.05 * pushFactor;
                    
                    // Đẩy tung cả ra phía sau (chiều Z) để tạo khối 3D
                    positions[i3+2] += force * 10 * (Math.random() - 0.5); 

                } else {
                    // --- HỒI PHỤC TỪ TỪ (Slow Motion Return) ---
                    const originX = originalPosArray[i3];
                    const originY = originalPosArray[i3+1];
                    const originZ = originalPosArray[i3+2];

                    // Tốc độ về chỗ cũ chậm hơn (0.015) để tạo cảm giác "lơ lửng"
                    positions[i3] += (originX - positions[i3]) * 0.015;
                    positions[i3+1] += (originY - positions[i3+1]) * 0.015;
                    positions[i3+2] += (originZ - positions[i3+2]) * 0.015;
                }
            }
            
            particlesGeometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
